"""
E-Commerce Data Analysis Dashboard
Optimized Streamlit code with:
1. Using Plotly instead of Folium (lighter & still interactive)
2. Using st.cache_data() for efficient data loading & per-page caching
3. Avoiding empty dataset issues with basic checks
4. A modular structure for clarity
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import plotly.express as px  # <--- Gantikan folium dengan Plotly

# =====================================================
# 1) SET PAGE CONFIG - Must be FIRST Streamlit command
# =====================================================
st.set_page_config(page_title="E-Commerce Data Analysis", layout="wide")

# ================================
# 2) Data Loading with Cache
# ================================
@st.cache_data
def load_data():
    """Load CSV datasets into DataFrames."""
    customer_df = pd.read_csv("customer_dataset.csv")
    geolocation_df = pd.read_csv("geolocation_dataset.csv")
    order_df = pd.read_csv("order_dataset.csv")
    order_items_df = pd.read_csv("order_items_dataset.csv")
    order_payments_df = pd.read_csv("order_payments_dataset.csv")
    product_df = pd.read_csv("product_dataset.csv")
    seller_df = pd.read_csv("seller_dataset.csv")
    return (
        customer_df,
        geolocation_df,
        order_df,
        order_items_df,
        order_payments_df,
        product_df,
        seller_df
    )

# Panggil load_data agar file CSV dibaca sekali saja
(
    customer_df,
    geolocation_df,
    order_df,
    order_items_df,
    order_payments_df,
    product_df,
    seller_df
) = load_data()

# ================================
# 3) Data Preprocessing (cached)
# ================================
@st.cache_data
def get_customer_geo(customer_df, geolocation_df):
    """Gabung data customer dan geolocation."""
    return pd.merge(
        customer_df,
        geolocation_df,
        left_on='customer_zip_code_prefix',
        right_on='geolocation_zip_code_prefix',
        how='inner'
    )

@st.cache_data
def get_seller_geo(seller_df, geolocation_df):
    """Gabung data seller dan geolocation."""
    return pd.merge(
        seller_df,
        geolocation_df,
        left_on='seller_zip_code_prefix',
        right_on='geolocation_zip_code_prefix',
        how='inner'
    )

customer_geo = get_customer_geo(customer_df, geolocation_df)
seller_geo   = get_seller_geo(seller_df, geolocation_df)

# ================================
# 4) Streamlit Layout & Navigation
# ================================
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to",
    [
        "Sale Trend",
        "Late Orders Analysis",
        "Payment Method Analysis",
        "City-wise Distribution"
    ]
)

# ================================
# 5) Page Implementations
# ================================

def page_sale_trend():
    """Halaman 1: Trend Penjualan"""
    st.header("Pertanyaan 1: Bagaimana trend penjualan di E-commerce di rentang tanggal tertentu?")
    st.subheader("Visualisasi: Tren Penjualan")
    
    @st.cache_data
    def get_merged_orders_for_sale_trend(order_df, order_items_df):
        merged_orders = pd.merge(order_df, order_items_df, on="order_id", how="inner")
        merged_orders["order_delivered_customer_date"] = pd.to_datetime(
            merged_orders["order_delivered_customer_date"]
        )
        return merged_orders

    merged_orders = get_merged_orders_for_sale_trend(order_df, order_items_df)

    if merged_orders.empty:
        st.error("Data orders tidak tersedia.")
        return

    min_date = merged_orders["order_delivered_customer_date"].min().date()
    max_date = merged_orders["order_delivered_customer_date"].max().date()

    selected_date_range = st.date_input(
        "Pilih rentang tanggal untuk melihat jumlah item terjual per hari:",
        [min_date, max_date]
    )

    if len(selected_date_range) == 2:
        start_date, end_date = selected_date_range
        if start_date > end_date:
            st.warning("Tanggal awal harus lebih kecil atau sama dengan tanggal akhir.")
        else:
            mask = (
                (merged_orders["order_delivered_customer_date"] >= pd.to_datetime(start_date)) &
                (merged_orders["order_delivered_customer_date"] <= pd.to_datetime(end_date))
            )
            range_data = merged_orders[mask]
            if range_data.empty:
                st.info("Tidak ada pesanan di rentang tanggal yang dipilih.")
            else:
                daily_item_count = (
                    range_data
                    .groupby(range_data["order_delivered_customer_date"].dt.date)["order_item_id"]
                    .count()
                )

                fig, ax = plt.subplots(figsize=(10, 5))
                ax.plot(
                    pd.to_datetime(daily_item_count.index),
                    daily_item_count.values,
                    marker='o',
                    linestyle='-',
                    color='orange'
                )
                ax.set_title("Daily Item Sold in Selected Date Range")
                ax.set_xlabel("Delivery Date")
                ax.set_ylabel("Number of Items Sold")
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%b, %Y'))
                ax.grid(True, alpha=0.3)

                st.pyplot(fig)
                st.markdown("**Insight:**")
                st.markdown(
                    """
                    - Pada periode akhir 2016 hingga awal 2017, jumlah item yang terjual per hari masih relatif rendah. 
                      Namun, seiring berjalannya waktu (mulai memasuki pertengahan 2017), terlihat peningkatan 
                      dari segi frekuensi maupun volume penjualan harian.
                    - Memasuki pertengahan 2017 hingga awal 2018, grafik menunjukkan lonjakan signifikan 
                      dengan beberapa hari mencapai penjualan di atas 300â€“500 item.
                    - Terdapat beberapa lonjakan di bulan-bulan tertentu saja (mis. liburan, diskon, dsb.).
                    - Secara garis besar, tren penjualan terus meningkat setiap kuartalnya.
                    """
                )

def page_late_orders_analysis():
    """Halaman 2: Analisis Pesanan Terlambat"""
    st.header("Pertanyaan 2: Berapa persentase pesanan yang terlambat sampai ke pelanggan?")
    
    @st.cache_data
    def get_delivered_orders(order_df):
        # Convert date
        order_df['order_estimated_delivery_date'] = pd.to_datetime(order_df['order_estimated_delivery_date'])
        order_df['order_delivered_customer_date'] = pd.to_datetime(order_df['order_delivered_customer_date'])
        return order_df[order_df['order_status'] == 'delivered'].copy()
    
    delivered_orders = get_delivered_orders(order_df)
    if delivered_orders.empty:
        st.error("Tidak ada data pesanan yang sudah dikirim.")
        return

    delivered_orders['late_delivery'] = (
        delivered_orders['order_delivered_customer_date'] >
        delivered_orders['order_estimated_delivery_date']
    )
    late_percentage = delivered_orders['late_delivery'].mean() * 100

    st.subheader("Visualisasi 1: Pie Chart On-Time vs Late")
    labels = ['On Time', 'Late']
    sizes = [100 - late_percentage, late_percentage]
    colors = ['#4CAF50', '#F44336']
    explode = (0.1, 0)

    fig, ax = plt.subplots(figsize=(4, 4))
    ax.pie(
        sizes,
        labels=labels,
        autopct='%1.1f%%',
        startangle=140,
        colors=colors,
        explode=explode
    )
    ax.set_title("Percentage of Orders Delivered On Time vs Late")
    st.pyplot(fig)

    st.markdown("**Insight (Pie Chart):**")
    st.markdown(
        f"""
        - Mayoritas pesanan (sekitar {100 - late_percentage:.1f}%) dikirim tepat waktu.
        - Faktor keterlambatan yang tersisa (sekitar {late_percentage:.1f}%) 
          bisa disebabkan oleh jarak pengiriman, logistik, 
          maupun lonjakan pembelian yang terlalu tinggi sehingga kurangnya persiapan.
        """
    )

    # Time series of lateness
    st.subheader("Visualisasi 2: Time Series Keterlambatan Pengiriman")

    @st.cache_data
    def get_orders_by_date(df):
        return df.groupby(df['order_delivered_customer_date'].dt.date).size()

    orders_by_date = get_orders_by_date(delivered_orders)
    late_orders_by_date = get_orders_by_date(delivered_orders[delivered_orders['late_delivery']])

    # Convert index to datetime
    import numpy as np
    if not orders_by_date.empty:
        orders_by_date.index = pd.to_datetime(orders_by_date.index)
    if not late_orders_by_date.empty:
        late_orders_by_date.index = pd.to_datetime(late_orders_by_date.index)

    orders_by_date_sma = orders_by_date.rolling(window=7).mean() if not orders_by_date.empty else pd.Series(dtype=float)
    late_orders_by_date_sma = late_orders_by_date.rolling(window=7).mean() if not late_orders_by_date.empty else pd.Series(dtype=float)

    fig, ax = plt.subplots(figsize=(10,5))
    if not orders_by_date.empty:
        ax.plot(
            orders_by_date.index,
            orders_by_date.values,
            marker='o',
            linestyle='-',
            color='lightblue',
            alpha=0.6,
            label="Daily Orders"
        )
        ax.plot(
            orders_by_date_sma.index,
            orders_by_date_sma.values,
            linestyle='-',
            color='blue',
            linewidth=2,
            label="7-Day Moving Avg - Orders"
        )
    if not late_orders_by_date.empty:
        ax.plot(
            late_orders_by_date.index,
            late_orders_by_date.values,
            marker='o',
            linestyle='-',
            color='lightcoral',
            alpha=0.6,
            label="Daily Late Orders"
        )
        ax.plot(
            late_orders_by_date_sma.index,
            late_orders_by_date_sma.values,
            linestyle='-',
            color='red',
            linewidth=2,
            label="7-Day Moving Avg - Late Orders"
        )

    ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
    ax.set_xlabel("Delivery Date (Month-Year)")
    ax.set_ylabel("Number of Orders")
    ax.set_title("Orders Delivered & Late Orders Over Time with Trend")
    ax.legend()
    ax.grid(alpha=0.3)
    # Miringkan label sumbu X
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right")

    st.pyplot(fig)

    st.markdown("**Insight (Time Series):**")
    st.markdown(
        """
        - Setiap lonjakan pembelian umumnya diikuti lonjakan keterlambatan.
        - Keterlambatan yang tinggi bisa menurunkan kepercayaan konsumen, 
          sehingga memengaruhi jumlah pembelian berikutnya.
        """
    )

def page_payment_method_analysis():
    """Halaman 3: Analisis Metode Pembayaran"""
    st.header("Pertanyaan 3: Metode pembayaran mana yang paling banyak digunakan dan mana yang paling jarang digunakan?")

    @st.cache_data
    def get_payment_counts(df):
        return df['payment_type'].value_counts()

    if order_payments_df.empty:
        st.error("Data payment tidak tersedia.")
        return

    payment_counts = get_payment_counts(order_payments_df)

    st.subheader("Visualisasi: Payment Method Usage Distribution")
    clean_labels = [lbl.replace("_", " ").title() for lbl in payment_counts.index]

    fig, ax = plt.subplots(figsize=(4,4))
    ax.pie(
        payment_counts,
        labels=clean_labels,
        autopct='%1.1f%%',
        startangle=140
    )
    ax.set_title("Payment Method Usage Distribution")
    st.pyplot(fig)

    st.markdown("**Insight (Payment Method Analysis):**")
    st.markdown(
        """
        - Metode pembayaran yang paling banyak digunakan adalah Credit Card.
        - Boleto juga menempati posisi yang cukup signifikan.
        - Metode lain seperti Voucher dan Debit Card memiliki proporsi yang lebih kecil.
        - Program promo atau voucher untuk pengguna kartu kredit berpotensi meningkatkan penjualan.
        """
    )

#
#  ðŸ”¥ðŸ”¹ðŸ”¹  PLOTLY REPLACING FOLIUM FOR MAPS  ðŸ”¹ðŸ”¹ðŸ”¥
#

def page_city_distribution():
    """Halaman 4: Distribusi Kota (Customer & Seller) dengan Plotly"""
    st.header("Pertanyaan 4: Kota mana yang memiliki jumlah pelanggan terbanyak dan kota mana yang memiliki jumlah penjual terbanyak?")

    # --- Bar Chart: Top 10 Cities (Customers) ---
    st.subheader("Visualisasi 1: Top 10 Cities with Most Customers")
    if customer_df.empty:
        st.error("Data customer tidak tersedia.")
        return

    @st.cache_data
    def get_top10_cities(customer_df):
        return (
            customer_df['customer_city']
            .str.title()
            .value_counts()
            .head(10)
        )

    city_customer_counts = get_top10_cities(customer_df)

    fig, ax = plt.subplots(figsize=(8,5))
    city_customer_counts.plot(kind='barh', ax=ax, color='royalblue')
    ax.set_title("Top 10 Cities with Most Customers")
    ax.set_xlabel("Number of Customers")
    ax.set_ylabel("City")
    st.pyplot(fig)

    st.markdown("**Insight (Top 10 Cities - Customers):**")
    st.markdown(
        """
        - Kota dengan jumlah pelanggan terbanyak biasanya kota besar 
          atau pusat bisnis (SÃ£o Paulo, Rio de Janeiro, dll.).
        - Distribusi pelanggan umumnya terpusat di wilayah tenggara Brasil.
        """
    )

    # ------------------
    # KePler HEATMAPS
    # ------------------
st.subheader("Visualisasi 2: Heatmap Customer & Seller (Kepler.gl)")

    if customer_geo.empty or seller_geo.empty:
        st.error("Data lokasi customer/seller tidak tersedia.")
        return

    @st.cache_data
    def prepare_kepler_data(customer_geo, seller_geo):
        """Mengubah DataFrame GeoPandas menjadi format JSON untuk Kepler.gl"""
        cust_json = customer_geo[['geolocation_lat', 'geolocation_lng']].rename(
            columns={'geolocation_lat': 'lat', 'geolocation_lng': 'lon'}
        )
        sell_json = seller_geo[['geolocation_lat', 'geolocation_lng']].rename(
            columns={'geolocation_lat': 'lat', 'geolocation_lng': 'lon'}
        )
        return cust_json, sell_json

    customer_json, seller_json = prepare_kepler_data(customer_geo, seller_geo)

    # Setup Kepler.gl Map
    kepler_map = KeplerGl(height=600)
    kepler_map.add_data(data=customer_json, name="Customer Density")
    kepler_map.add_data(data=seller_json, name="Seller Density")

    # Render Kepler.gl Map
    st.markdown("**Customer & Seller Heatmap**")
    keplergl_static(kepler_map)

    st.markdown("**Insight (Heatmaps):**")
    st.markdown(
        """
        - Peta kepadatan pelanggan dan penjual memperlihatkan konsentrasi tertinggi 
          di area perkotaan padat penduduk.
        - Dengan mengetahui lokasi penjual dan pelanggan, kita bisa mengoptimalkan 
          strategi pengiriman dan gudang.
        - Adanya pembeli dari luar Amerika Selatan membuka peluang untuk ekspansi global.
        """
    )

# ================================
# 6) Render Pages
# ================================
if page == "Sale Trend":
    st.write("Halaman Sale Trend belum diperbarui.")
elif page == "Late Orders Analysis":
    st.write("Halaman Late Orders Analysis belum diperbarui.")
elif page == "Payment Method Analysis":
    st.write("Halaman Payment Method Analysis belum diperbarui.")
elif page == "City-wise Distribution":
    page_city_distribution()